totalList = [a0,a1,a2,a3,a4,a5,a6,a7.... a102]

하나의 페이지에 3개의 객체를 보여줌

1번 페이지 - [a0, a1, a2]
2번 페이지 - [a3, a4, a5]
3번 페이지 - [a6, a7, a8]
...

1 - 0, 2
2 - 3, 5
3 - 6, 8
4 - 9, 11
...
35 - 102 // 마지막 index까지만 추출해라

startIndex = 3( n - 1)
endIndex = 3 * n - 1

103 객체 - 34.3333... 올림처리 = 35개 페이지 발생
< 1 2 3 4 5  6 7 8 9 10 ... 35>

totalPage = [1,2,3,4,5,6,7,8... 35]

하나의 섹션에서 10개의 페이지 번호를 보여준다고 하면,
1번 섹션 - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
2번 섹션 - [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
3번 섹션 - [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]

startIndex = 10 * ( n - 1 )
endIndex = 10 * n - 1

방법은 2가지

--------------------------------------------------------------
< 커스텀 훅 > 
    -> :일반 함수에서는, 상태를 사용해야 하는데, useState or useEffect나 이런 훅 함수들을 써야하는데,
        이 훅들은 사용 가능한 위치가, 컴포넌트 위치에서만 사용할 수 있다. 훅 안에서만 훅을 사용할 수 있다.

        GPT 설명 
        1.
        **일반 함수를 사용하는 경우:**
        1. **상태 관리가 어려움 : 페이지네이션과 관련된 상태를 유지하기 위해선 useState와 같은 리액트 훅을 사용해야 합니다. 하지만 함수형 컴포넌트 외부에서는 훅을 사용할 수 없으므로,
                                 상태를 유지하기 위해 클래스 컴포넌트의 state를 활용하거나 외부 변수를 사용해야 합니다.
        2. **렌더링이 어려움 : 페이지네이션 로직이 복잡해질수록, 렌더링을 제어하는 것이 어려워집니다. 예를 들어, 페이지 번호를 클릭할 때마다 해당 페이지에 대한 데이터를 새로 가져와야 
                              할 때, 렌더링 로직을 일반 함수로 구현하면 복잡해질 수 있습니다.
        3. **재사용이 어려움 : 일반 함수로 구현한 페이지네이션 로직은 해당 컴포넌트 내에서만 사용할 수 있습니다. 
                              다른 컴포넌트에서 같은 페이지네이션 로직을 사용하려면 중복된 코드를 작성해야 합니다.
        
        **커스텀 훅을 사용하는 경우:**
        1. **상태 관리가 용이함 : 커스텀 훅은 내부에서 useState와 같은 훅을 사용하여 상태를 관리할 수 있습니다. 이로써 페이지네이션과 관련된 상태를 편리하게 관리할 수 있습니다.
        2. **렌더링 제어가 편리함 : 커스텀 훅을 사용하면 페이지네이션 로직을 간결하고 효율적으로 관리할 수 있습니다. 
                                    커스텀 훅을 사용하여 페이지 번호를 클릭할 때마다 해당 페이지에 대한 데이터를 새로 가져오는 등의 렌더링 로직을 쉽게 구현할 수 있습니다.
        3. **재사용이 용이함 : 커스텀 훅으로 구현한 페이지네이션 로직은 다른 컴포넌트에서 쉽게 재사용할 수 있습니다. 
                              필요한 경우 해당 커스텀 훅을 다른 컴포넌트에서 import하여 사용할 수 있습니다.
                              종합적으로, 페이지네이션을 구현할 때 커스텀 훅을 사용하는 것이 상태 관리, 렌더링 제어, 재사용성 측면에서 효율적입니다. 
                              커스텀 훅을 사용하면 코드를 간결하게 유지하고, 페이지네이션 로직을 효율적으로 관리할 수 있습니다.
        
        2.
        커스텀 훅(custom hook)은, 
        :리액트에서 재사용 가능한 로직을 분리하여 관리하는 기법입니다. 이를 통해 컴포넌트 간에 공통된 로직을 쉽게 공유하고 재사용할 수 있습니다.
         커스텀 훅은 함수형 컴포넌트 내부에서만 정의할 수 있습니다. 그리고 주로 상태(state)나 생명주기 함수(useEffect, useMemo 등)를 다루는 로직을 분리하여 만듭니다.
         예를 들어, 페이지네이션과 관련된 로직을 분리하여 커스텀 훅으로 만들 수 있습니다. 이를 통해 여러 컴포넌트에서 동일한 페이지네이션 로직을 사용할 수 있습니다.
         커스텀 훅은 보통 use 접두어를 사용하여 정의한다. ex) usePagination

front 처리 -> 전체 리스트의 길이가 적을 적에 front 처리가 좋음
           -> 부하를 줄이고 싶다? front가 낫다. 지금 수준에서는 유리
--------------------------------------------------------------

back에서 전체 객체 리스트를 받아옴
front에서 슬라이싱 처리

--------------------------------------------------------------
back 처리 -> 전체 리스트의 길이가 굉장히 길적에 back 처리가 좋음
          -> 단점, 페이지를 이동시킬 때마다 리퀘스트를 보내야해서 부하 up
--------------------------------------------------------------

client로부터 현제 페이지 번호를 받아옴
해당 페이지에서 보여줄 객체 리스트만 응답 + 전체 객체 객수 반환 해야함


--------------------------------------------------------------

이전, 다음 버튼 동작 로직

ex)

2 -> 10
3 -> 20
4 -> 30

(currentSection - 1 ) * 10

1 -> 11
2 -> 21
3 -> 31

currentSection * 10 + 1


